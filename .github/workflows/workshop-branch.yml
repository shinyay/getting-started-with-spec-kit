name: "Workshop: Create dated branch from Issue"

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write

# Prevent two issues from racing on the same branch name
concurrency:
  group: workshop-branch-${{ github.repository }}
  cancel-in-progress: false

jobs:
  create-branch:
    runs-on: ubuntu-latest
    # Match by label OR title prefix â€” labels may not exist yet in new repos
    if: >-
      contains(github.event.issue.labels.*.name, 'workshop-branch-request') ||
      contains(github.event.issue.labels.*.name, 'workshop') ||
      startsWith(github.event.issue.title, '[workshop]')

    steps:
      - name: Create branch from Issue form
        uses: actions/github-script@v7
        with:
          script: |
            // â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const actor = issue.user?.login ?? "unknown";
            const bodyText = issue.body ?? "";

            // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            // Parse a ### section from the GitHub Issue form body
            function getSection(heading) {
              const esc = heading.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              const re = new RegExp(
                `^###\\s+${esc}\\s*\\n([\\s\\S]*?)(?=\\n###\\s|$)`, "m"
              );
              const m = bodyText.match(re);
              if (!m) return "";
              const v = m[1].trim();
              return (v === "_No response_" || v === "No response") ? "" : v;
            }

            // Post a comment on the issue
            async function comment(msg) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: issueNumber, body: msg,
              });
            }

            // Sanitize a string into a safe git-ref slug
            function slugify(s) {
              return String(s || "")
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")
                .replace(/^-+|-+$/g, "")
                .slice(0, 40);
            }

            // Write a line to the Actions job summary
            function summary(md) {
              core.summary.addRaw(md + "\n");
            }

            // â”€â”€ 1. Permission check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let permission = "none";
            try {
              const resp = await github.rest.repos.getCollaboratorPermissionLevel({
                owner, repo, username: actor,
              });
              permission = resp.data.permission;
            } catch (e) {
              core.warning(`Permission lookup failed for @${actor}: ${e.message}`);
            }

            if (!["admin", "maintain", "write"].includes(permission)) {
              const msg =
                `âš ï¸ **Permission denied**\n\n` +
                `Branch creation requires **write / maintain / admin** access.\n\n` +
                `| Field | Value |\n|---|---|\n` +
                `| Actor | @${actor} |\n` +
                `| Permission | \`${permission}\` |\n\n` +
                `Ask a maintainer to create the branch, or run this on your fork.`;
              await comment(msg);
              core.setFailed(`Insufficient permission: ${permission}`);
              return;
            }

            // â”€â”€ 2. Parse inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const dateInput   = getSection("Workshop date (YYYY-MM-DD)");
            const baseRefRaw  = getSection("Base ref (branch or tag)") || "main";
            const prefixRaw   = getSection("Branch prefix") || "workshop";
            const suffixRaw   = getSection("Optional suffix (slug)");
            const onExists    = getSection("If the branch already exists") || "Comment and do nothing";
            const postAction  = getSection("After the branch is created") || "Comment with checkout instructions";
            const dryRunField = getSection("Dry run");
            const isDryRun    = dryRunField.toLowerCase().includes("yes");

            // â”€â”€ 3. Validate date â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const createdAt = issue.created_at ? String(issue.created_at).slice(0, 10) : "";
            const date = dateInput.length > 0 ? dateInput : createdAt;

            if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
              await comment(
                `âŒ **Invalid date:** \`${dateInput || "(empty)"}\`\n\n` +
                `Expected format: **YYYY-MM-DD** (e.g. \`2026-01-07\`).\n` +
                `Leave blank to use the Issue created date: \`${createdAt}\`.`
              );
              core.setFailed("Invalid date format.");
              return;
            }

            // Extra: reject obviously impossible dates
            const [y, m, d] = date.split("-").map(Number);
            const dateObj = new Date(Date.UTC(y, m - 1, d));
            if (dateObj.getUTCFullYear() !== y || dateObj.getUTCMonth() !== m - 1 || dateObj.getUTCDate() !== d) {
              await comment(
                `âŒ **Invalid calendar date:** \`${date}\` does not exist.\n` +
                `Please enter a real date in YYYY-MM-DD format.`
              );
              core.setFailed("Invalid calendar date.");
              return;
            }

            // â”€â”€ 4. Validate & sanitize prefix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const prefix = slugify(prefixRaw);
            if (prefix.length === 0) {
              await comment(
                `âŒ **Invalid branch prefix:** \`${prefixRaw}\`\n\n` +
                `Use only letters, numbers, and hyphens (e.g. \`workshop\`).`
              );
              core.setFailed("Invalid branch prefix.");
              return;
            }

            // â”€â”€ 5. Validate & sanitize suffix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const suffix = slugify(suffixRaw);
            if (suffixRaw && suffixRaw.trim().length > 0 && suffix.length === 0) {
              await comment(
                `âŒ **Invalid suffix:** \`${suffixRaw}\`\n\n` +
                `Use only lowercase letters, numbers, and hyphens (e.g. \`tokyo-a\`, \`team2\`).`
              );
              core.setFailed("Invalid suffix.");
              return;
            }

            // â”€â”€ 6. Validate base ref â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const baseRef = baseRefRaw.trim();
            if (baseRef.length === 0 || /\s/.test(baseRef)) {
              await comment(
                `âŒ **Invalid base ref:** \`${baseRefRaw}\`\n\n` +
                `Must be a branch or tag name with no spaces.`
              );
              core.setFailed("Invalid base ref.");
              return;
            }

            // â”€â”€ 7. Build branch name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let branchName = `${prefix}/${date}`;
            if (suffix) branchName += `-${suffix}`;

            // â”€â”€ 8. Resolve base ref to commit SHA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function resolveCommitSha(refName) {
              const normalized = String(refName).replace(/^refs\//, "");
              const candidates = [];

              if (normalized.startsWith("heads/") || normalized.startsWith("tags/")) {
                candidates.push(normalized);
              } else {
                candidates.push(`heads/${normalized}`, `tags/${normalized}`);
              }

              let refData = null;
              for (const c of candidates) {
                try {
                  const r = await github.rest.git.getRef({ owner, repo, ref: c });
                  refData = r.data;
                  break;
                } catch (e) {
                  if (e.status !== 404) throw e;
                }
              }
              if (!refData) throw new Error(`Ref not found: \`${refName}\``);

              // Dereference annotated tags â†’ commit
              let sha  = refData.object.sha;
              let type = refData.object.type;
              let guard = 0;
              while (type === "tag" && guard++ < 5) {
                const tag = await github.rest.git.getTag({ owner, repo, tag_sha: sha });
                sha  = tag.data.object.sha;
                type = tag.data.object.type;
              }

              if (type !== "commit") {
                throw new Error(`Ref \`${refName}\` resolved to type \`${type}\`, not a commit.`);
              }
              return sha;
            }

            let baseSha;
            try {
              baseSha = await resolveCommitSha(baseRef);
            } catch (e) {
              await comment(
                `âŒ **Failed to resolve base ref:** \`${baseRef}\`\n\n` +
                `Error: ${e.message}\n\n` +
                `Make sure the branch or tag exists in this repository.`
              );
              core.setFailed(e.message);
              return;
            }

            // â”€â”€ 9. Dry run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (isDryRun) {
              const msg =
                `ğŸ” **Dry run â€” no branch created**\n\n` +
                `All inputs are valid. Here's what would happen:\n\n` +
                `| Field | Value |\n|---|---|\n` +
                `| Branch | \`${branchName}\` |\n` +
                `| Base ref | \`${baseRef}\` |\n` +
                `| Base SHA | \`${baseSha.slice(0, 12)}\` |\n` +
                `| On exists | ${onExists} |\n` +
                `| Post action | ${postAction} |\n\n` +
                `Create a **new** Issue without dry run to create the branch.`;
              await comment(msg);
              summary(`## ğŸ” Dry Run\n\nBranch \`${branchName}\` validated successfully (not created).`);
              await core.summary.write();
              return;
            }

            // â”€â”€ 10. Check if branch already exists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let exists = false;
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${branchName}` });
              exists = true;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            if (exists) {
              const branchUrl = `https://github.com/${owner}/${repo}/tree/${branchName}`;
              const msg =
                `â„¹ï¸ **Branch already exists:** [\`${branchName}\`](${branchUrl})\n\n` +
                `No changes were made.`;

              if (onExists.toLowerCase().includes("fail")) {
                await comment(msg);
                core.setFailed("Branch already exists.");
                return;
              }
              await comment(msg);
              summary(`## â„¹ï¸ Branch Exists\n\n\`${branchName}\` already exists â€” skipped.`);
              await core.summary.write();
              return;
            }

            // â”€â”€ 11. Create the branch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            await github.rest.git.createRef({
              owner, repo,
              ref: `refs/heads/${branchName}`,
              sha: baseSha,
            });

            const branchUrl = `https://github.com/${owner}/${repo}/tree/${branchName}`;

            // â”€â”€ 12. Comment with results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const msg =
              `âœ… **Branch created:** [\`${branchName}\`](${branchUrl})\n\n` +
              `| Field | Value |\n|---|---|\n` +
              `| Base ref | \`${baseRef}\` |\n` +
              `| Base SHA | \`${baseSha.slice(0, 12)}\` |\n` +
              `| Created by | @${actor} |\n\n` +
              `### Checkout\n\n` +
              "```bash\n" +
              `git fetch origin ${branchName}\n` +
              `git checkout ${branchName}\n` +
              "```\n\n" +
              `### Next steps\n\n` +
              `1. Start working on branch \`${branchName}\`\n` +
              `2. Open Issues or assign tasks for this workshop session\n` +
              `3. Create a PR when ready to merge changes back\n`;

            await comment(msg);

            // â”€â”€ 13. Post action: optionally close the issue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (postAction.toLowerCase().includes("close")) {
              await github.rest.issues.update({
                owner, repo, issue_number: issueNumber, state: "closed",
              });
            }

            // â”€â”€ 14. Job summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            summary(`## âœ… Branch Created`);
            summary(`| Field | Value |\n|---|---|`);
            summary(`| Branch | [\`${branchName}\`](${branchUrl}) |`);
            summary(`| Base | \`${baseRef}\` (\`${baseSha.slice(0, 12)}\`) |`);
            summary(`| Issue | #${issueNumber} |`);
            summary(`| Actor | @${actor} |`);
            await core.summary.write();
